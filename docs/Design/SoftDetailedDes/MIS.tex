\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
10/11/25 & Rev -1 & \\
21/01/26 & Rev 0 & \\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/ritual-17/flow/tree/main/docs/SRS-Meyer}

%\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname{}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/ritual-17/flow}.

\section{Notation}

%\wss{You should describe your notation.  You can use what is below as
%  a starting point.}
%
%The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
%with the addition that template modules have been adapted from
%\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
%\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
%multiple assignment statement and conditional rules follow the form $(c_1
%\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.
%
%The following table summarizes the primitive data types used by \progname.
%
%\begin{center}
%\renewcommand{\arraystretch}{1.2}
%\noindent
%\begin{tabular}{l l p{7.5cm}}
%\toprule
%\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\
%\midrule
%character & char & a single symbol or digit\\
%integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
%natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
%real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
%\bottomrule
%\end{tabular}
%\end{center}

\noindent
The specification of \progname\ uses several derived data types, including
sequences, strings, and tuples. Sequences are ordered lists containing elements
of the same data type. Strings are sequences of characters. Tuples represent a
finite collection of values, potentially of different types. Functions are
described by specifying the data types of their inputs and outputs, and local
functions are documented using their type signatures followed by their
behavioural descriptions.

\noindent
Several modules, most notably the Shape Interface Module, operate on geometric
objects that are placed on a two-dimensional canvas. Shapes are treated
abstractly and are not tied to a specific rendering or user interface
implementation. A shape is represented conceptually as a tuple consisting of a
shape type and a finite set of parameters. The shape type is drawn from a
predefined set of supported shapes (e.g., rectangle, circle, text box), while
the parameters describe properties such as position, size, and orientation.

\noindent
Positions are expressed using Cartesian coordinates in a two-dimensional plane,
typically represented as $(x, y)$ pairs of real numbers. The canvas may be
conceptually overlaid with a uniform grid that provides a visual reference and
optional alignment structure for placing and manipulating shapes. The grid does
not impose semantic constraints on shape placement, but may be used to support
consistent positioning, snapping behaviour, or alignment operations. Dimensions
such as width, height, or radius are represented using real-valued quantities.
Collections of shapes are represented as sequences of shape tuples. Operations
on shapes, such as insertion, deletion, movement, resizing, or transformation,
are described in terms of updates applied to these abstract representations.
Any constraints on valid coordinates or dimensions are specified explicitly in
the relevant module interfaces.

\section{Module Decomposition}

%The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & \ref{Display Interface Module} {Display Interface Module}  \\
& \ref{Input Interface Module} {Input Interface Module}\\
& \ref{File Interface Module} {File Interface Module}\\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} & \ref{Geometry State Parser Module} {Geometry State Parser Module}\\
& \ref{Geometry State Converter Module} {Geometry State Converter Module}\\
& \ref{Commands Parser Module} {Commands Parser Module}\\
& \ref{Mode Commands Module} {Mode Commands Module}\\
& \ref{Shape Interface Module} {Shape Interface Module}\\
& \ref{User Preference Module} {User Preference Module}\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & \ref{Text Buffer Module} {Text Buffer Module}\\
& \ref{Geometry State Module} {Geometry State Module}\\
& \ref{Geometry State Mutator Module} {Geometry State Mutator Module}\\
& \ref{Undo Redo Module} {Undo Redo Module}\\
& \ref{User Persistence Module} {User Persistence Module}\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of {Display Interface Module}} \label{Display Interface Module}
%\wss{Use labels for  cross-referencing}

%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

%\wss{Short name for the module}
Display for the system

This is the module that will handle the display for the system.
 This is a module that when called updates the display.
\subsection{Uses}
\ref{Geometry State Module} {Geometry State Module}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
display & Shapes & Display to screen & - \\
resize & width, length & Resize the screen as needed & - \\
status &  & Show status & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

\begin{itemize}
	\item System Screen
	\item Rendering API
\end{itemize}
%\wss{This section is not necessary for all modules.  Its purpose is to capture  when the module has external interaction with the environment, such as for   device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

%\wss{Try to minimize assumptions and anticipate programmer errors via  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {display}(Shapes):
\begin{itemize}

\item output: Outputs Shapes visually on the screen
\end{itemize}

\noindent {resize}(length,width):
\begin{itemize}

\item output: Outputs resized version of the current screen
\end{itemize}

\noindent {status}():
\begin{itemize}

\item output: Outputs current status of the program e.g. waiting for input, rendering etc.
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}

%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}
N/A

\newpage
\section{MIS of {Input Interface Module}} \label{Input Interface Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

Input Module. Deals with User inputs and passes them on to the \ref{Mode Commands Module} {Mode Commands Module}

\subsection{Uses}
\ref{Mode Commands Module} {Mode Commands Module}
\subsection{Syntax}

\subsubsection{Exported Constants}



\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
 get\_keyboard\_inputs & - & keyboard\_inputs & - \\
\hline
 get\_mouse\_inputs & - & mouse\_inputs & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\subsubsection{Environment Variables}

%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
\begin{itemize}
\item{Keyboard API}
\item{Mouse API}
\end{itemize}

\subsubsection{Assumptions}

%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {get\_keyboard\_inputs}():
\begin{itemize}
\item output: Data containing all current keyboard inputs. All keys will be off if the user is not using a keyboard.
\end{itemize}

\noindent {get\_mouse\_inputs}():
\begin{itemize}
\item output: Data containing mouse location and inputs. All inputs are off if the user does not have a mouse.
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}
N/A
\newpage
\section{MIS of {File Interface Module}} \label{File Interface Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\ref{Geometry State Parser Module} {Geometry State Parser Module}

\subsection{Uses}

\ref{Mode Commands Module} {Mode Commands Module}

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{open} & file\_path & opened\_file & Invalid File \\
\hline
{save} & file\_path, opened\_note & success & Saving Error \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}
N/A

\subsubsection{Environment Variables}

%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
\begin{itemize}
\item File System
\end{itemize}
\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {open}(file\_path):
\begin{itemize}
\item output: The opened file
\item exception: Invalid File if file is missing or of an incorrect type.
\end{itemize}
\noindent {save}(file\_path, opened\_note):

\begin{itemize}
\item output: If the Module was successful in saving opened\_note to file\_path
\item exception: No Space if there is not enough space to save the file.

\end{itemize}
%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {Geometry State Parser Module}} \label{Geometry State Parser Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

File parser takes the file input and parses it into data structure containing all shapes which is then stored by the \ref{Geometry State Module} {Geometry State Module} which holds all shape data.
%\wss{Short name for the module}

\subsection{Uses}

\ref{Geometry State Module} {Geometry State Module}

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{parse} & opened\_file & shapes & Invalid File \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
%
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
N/A

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {parse}(opened\_file):
\begin{itemize}
\item output: Data structure containing all shapes from the given file.
\item exception: Invalid File: if the file given is able to be parsed.
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {Geometry State Converter Module}} \label{Geometry State Converter Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

Note converter that converts notes to files of different file types, sending it to the file interface module
%\wss{Short name for the module}

\subsection{Uses}
\ref{File Interface Module} {File Interface Module}

\subsection{Syntax}

\subsubsection{Exported Constants}
Legal file types
\begin{itemize}
\item{PDF}
\item{fnote}
\end{itemize}
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{convert} & opened\_note, file\_type & file & Invalid file\_type \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}

\subsubsection{Environment Variables}

%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {convert}(opened\_note, file\_type):
\begin{itemize}
\item output: file that is ready to be saved on the computer.
\item exception: Invalid file\_type if the given file type is not compatable with the ones implemented
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}
convert\_*(opened\_note) functions that do the converting once the file type has been determined. (ex convert\_pdf)

\newpage
\section{MIS of {Commands Parser Module}} \label{Commands Parser Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

%\wss{Short name for the module}
Command Parser, converts keyboard inputs into commands and passes them onto the shape mutator.

\subsection{Uses}
\ref{Geometry State Mutator Module} {Geometry State Mutator Module}
\ref{User Preference Module} {User Preference Module}
\subsection{Syntax}

\subsubsection{Exported Constants}

Command names or ids e.g. ctrl + s -$>$ $<$C-s$>$, d + d -$>$ "dd"

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{parse\_commands} & keyboard\_inputs, mouse\_inputs & parsed\_input & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
Inputs have been already cleaned by the other modules.
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {parse\_commands}(keyboard\_inputs, mouse\_inputs):
\begin{itemize}
\item output: commands, which would be used by the Geometry State Mutator Module \ref{Geometry State Mutator Module}
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}
N/A

\newpage
\section{MIS of {Mode Commands Module}} \label{Mode Commands Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

Main Module contains the commands usable in the current mode.

\subsection{Uses}
N/A
\subsection{Syntax}

\subsubsection{Exported Constants}
Modes:
\begin{itemize}
\item{normalMode}
\item{insertMode}
\item{visualMode}
\item{commandMode}
\item{lineMode}
\item{textMode}
\end{itemize}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{get\_commands} & mode & commands & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}
N/A
\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
Mode given will always be a valid mode.
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {get\_commands}(mode):
\begin{itemize}
\item output: commands that can be run in the given mode
\end{itemize}
%
%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage\section{MIS of {Shape Interface Module}} \label{Shape Interface Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Module that contains information about shapes.

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}
Shapes: Types of shapes
\begin{itemize}
\item{Rectangle}
\item{circle}
\item{Triangle}
\item{Text Box}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{create\_shape} & shape\_type, points & shape & Invalid Points \\
\hline
{move\_shape} & shape, new\_points & - & Invalid Points \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}
N/A
\subsubsection{Environment Variables}
%
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
N/A
\subsubsection{Assumptions}
%
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}
N/A
\subsubsection{Access Routine Semantics}

\noindent {create\_shape}(shape\_type, points ):
\begin{itemize}
\item output: Shape with type shape\_type using points for location and size.
\item exception: Invalid points if the points are not possible for the type of shape.
\end{itemize}

\noindent {move\_shape}():
\begin{itemize}
\item transition: changes the points of the shape to the new points
\item exception: Invalid points if the points are not possible for the type of shape.
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {User Preference Module}} \label{User Preference Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
User preferences, provides an interface for creating and manipulating user preferences in the system.
%\wss{Short name for the module}

\subsection{Uses}
\ref{Display Interface Module} {Display Interface Module}
\ref{User Persistence Module} {User Persistence Module}
\subsection{Syntax}

\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{2cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{get\_command\_prefrences} & mode & commands & - \\
\hline
{modify} & - & - & - \\
\hline
{get\_theme\_prefrences} & - & theme & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
Command preferences: users defined commands
Theme preferences: user theme prefrences
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}

\subsubsection{Environment Variables}
%
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
%
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {get\_command\_prefrences}(mode):
\begin{itemize}
\item output: Any user defined preferences for the current mode
\end{itemize}

\noindent {modify}():
\begin{itemize}
\item transition: Has the user input their preferences where the moudles saves it to a file.
\end{itemize}

\noindent {get\_theme\_prefrences}():
\begin{itemize}
\item output: Theme preferences for the system
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {Text Buffer Module}} \label{Text Buffer Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
TextBuffer
%\wss{Short name for the module}

\subsection{Uses}
Geometry State Module (\ref{Geometry State Module})

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{6cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{createText} & location, text, formatting & TextID & Invalid Location \\
\hline
{modifyText} & TextID, text & - & Text Not Found  \\
\hline
{moveText} & TextID, newLocation & TextObject & Text Not Found \\
\hline
{deleteText} & TextID & - & Text Not Found \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}
text : Map$<$TextID, TextObject$>$

\noindent {Where TextObject contains:}
\begin{itemize}
\item position : location
\item content : string
\end{itemize}

\subsubsection{Environment Variables}
Screen (for rendering text)

%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
TextIDs are unique and immutable.
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {createText}(location, text, formatting):
\begin{itemize}
\item transition: Text box at location with text and formatting
\item output: TextID of the created text box
\item exception: Invalid Location
\end{itemize}

\noindent {modifyText}(TextID, text):
\begin{itemize}
\item transition: Text in text box is modified to now contain text with formatting
\item exception: Text Not Found
\end{itemize}

\noindent {moveText}(TextID, newLocation):
\begin{itemize}
\item transition: text box is moved to location.
\item exception: Text Not Found
\end{itemize}
\noindent {deleteText}(TextID):
\begin{itemize}
\item transition: text box is removed from the text buffer
\item exception: Text Not Found
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

generateTextID() : TextID
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {Geometry State Module}} \label{Geometry State Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

GeometryState (\ref{Geometry State Module})
%\wss{Short name for the module}

\subsection{Uses}
None

\subsection{Syntax}

\subsubsection{Exported Constants}
ShapeType = {Circle, Rectangle, Triangle, TextBox} \\
LineType = {Line, Arrow}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{getShapes} & - & Set$<$Shape$>$ & - \\
\hline
{getText} & - & Set$<$TextBox$>$ & - \\
\hline
{getLines} & - & Set$<$Line$>$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item Shapes : Set$<$Shape$>$
\item TextBoxes : Set$<$TextBox$>$
\item Lines : Set$<$Line$>$
\end{itemize}
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}

\subsubsection{Environment Variables}
%
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
None
\subsubsection{Assumptions}
Geometry is immutable except via Geometry State Mutator Module (\ref{Geometry State Mutator Module}).
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {getShapes}():
\begin{itemize}
\item output: Data Structure containing all shapes
\end{itemize}

\noindent {getText}():
\begin{itemize}
\item output: Data structure containing all text boxes
\end{itemize}

\noindent {getLines}():
\begin{itemize}
\item output: Data structure containing all lines
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
None
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {Geometry State Mutator Module}} \label{Geometry State Mutator Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
GeometryStateMutator (\ref{Geometry State Mutator Module})

%\wss{Short name for the module}

\subsection{Uses}
{Undo Redo Module} (\ref{Undo Redo Module}),
{Geometry State Module} (\ref{Geometry State Module})
\subsection{Syntax}

\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{addShape} & shapeSpec & GeometryID & Invalid Spec \\
\hline
{addLine} & lineSpec & GeometryID & Invalid Spec \\
\hline
{delete} & GeometryID & - & Not Found \\
\hline
{resize} & GeometryID & - & Not Found \\
\hline
{move} & GeometryID, location & - & Not Found, Invalid Transform \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}

\subsubsection{Environment Variables}
None
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
Mutations must be recorded by Undo Redo Module.
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {addShape}(shapeSpec):
\begin{itemize}
\item transition: Adds the shape to the canvas
\item output: GeometryID of the added shape
\item exception: Invalid Spec if the shapeSpec is invalid
\end{itemize}

\noindent {addLine}(lineSpec):
\begin{itemize}
\item transition: Adds the line to the canvas
\item output: GeometryID of the added line
\item exception: Invalid Spec if the lineSpec is invalid
\end{itemize}

\noindent {delete}(GeometryID):
\begin{itemize}
\item transition: Deletes the shape/line/textbox with the given GeometryID
\item exception: Not Found if the GeometryID does not exist
\end{itemize}

\noindent {resize}(GeometryID):
\begin{itemize}
\item transition: Resizes the shape/line/textbox with the given GeometryID
\item exception: Not Found if the GeometryID does not exist
\end{itemize}

\noindent {move}(GeometryID, location):
\begin{itemize}
\item transition: Moves the shape/line/textbox with the given GeometryID to location
\item exception: Not Found if the GeometryID does not exist
\item exception: Invalid Transform if the location is invalid
\end{itemize}


%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
None
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {Undo Redo Module}} \label{Undo Redo Module}
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
UndoRedoModule (\ref{Undo Redo Module})
%\wss{Short name for the module}

\subsection{Uses}
{Geometry State Module} (\ref{Geometry State Module})
\subsection{Syntax}

\subsubsection{Exported Constants}
None
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{undo} & - & - & Cant Undo \\
\hline
{redo} & - & - & Cant Redo \\
\hline
{addCommand} & command & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item undoStack : Stack$<$Command$>$
\item redoStack : Stack$<$Command$>$
\end{itemize}
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}

\subsubsection{Environment Variables}

%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
None
\subsubsection{Assumptions}
Commands fully capture inverse operations.
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {undo}():
\begin{itemize}
\item transition: Pops command from undoStack, executes its inverse, and pushes it onto redoStack
\item exception: Cant Undo if undoStack is empty
\end{itemize}

\noindent {redo}():
\begin{itemize}
\item transition: Pops command from redoStack, re-executes it, and pushes it onto undoStack
\item exception: Cant Redo if redoStack is empty
\end{itemize}

\noindent {addCommand}(command):
\begin{itemize}
\item transition: Pushes command onto undoStack and clears redoStack
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage
\section{MIS of {User Persistence Module}} \label{User Persistence Module}
%\wss{Use labels for
%  cross-referencing}

%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
UserPersistenceModule (\ref{User Persistence Module})

%\wss{Short name for the module}

\subsection{Uses}
{User Preference Module} (\ref{User Preference Module})

\subsection{Syntax}

\subsubsection{Exported Constants}
None
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
{save} & FilePath & - & IOError \\
\hline
{load} & FilePath & User Themes and Saves & IOError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}

\subsubsection{Environment Variables}
File System

%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
File format is versioned and backward compatible.
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent {save}(commands,theme):
\begin{itemize}
\item transition: Saves user preferences to file at FilePath
\item exception: IOError if there is an issue writing to the file
\end{itemize}

\noindent {load}(FilePath):
\begin{itemize}
\item output: User Themes and Saves loaded from file at FilePath
\item exception: IOError if there is an issue reading from the file
\end{itemize}


%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}
None
\newpage


\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

%\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable?
  \begin{itemize}
    \item Chengze - While we got back on MG and MIS document after some of the implementation,
    we had a better understanding of the overall design of the project. This allowed us to
    better fill in the details of each module and their services. In particular, reviewing the
    specifications helped us identify missing requirements and confirm that our current code
    matches the intended module responsibilities. Writing this deliverable also made it easier
    to see how the system should be organized, ensuring that each component has a clear purpose
    and well-defined interface moving forward.
    \item Ethan - In this deliverable we got a better idea of how the app would
      look and work from an architecture standpoint. It let us get a more
      concrete understanding of how components would be broken down in the code
      and how they would work together. Additionally, it helped us to write out
      some scaffold code for our rev 0 and do some work in parallel to better
      visualize module interactions and dependency.
    \item Hussain - In this deliverable, we were able to begin thinking more on
    the development of Flow. By discussing and outlining the different modules
    and their services, I believe we were able to get a much better
    understanding of how we can put together a successful application for this
    project. We were assigned this document close to the due date of Rev0 which
    is our first real revision of the finished project. This also pushes us to
    use the decisions made in this document directly in the development of our
    project.
    \item Jeffrey -
    \item Kevin -
  \end{itemize}
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
    \begin{itemize}
      \item Chengze - The pain point I experienced during this deliverable
      was the lack of clarity on some of the module services. Since some of the
      modules were not fully implemented yet, it was hard to determine what
      services they should provide. To resolve this, we had to rework on MIS to
      include more details and make sure the services aligned with the overall
      design of the project.
      \item Ethan - Overall I think this was the most challenging deliverable
        so far. This was where we had to go from ideas to a concrete system
        design. I have more experience in web development and backend system
        design, but not as much in designing something like a text editor or
        geometry manipulation program. It was difficult to think about all of
        the modules and how they would interact with eachother without writing
        any code. I helped resolve this by writing out some potentially
        throw-away code to play with while designing.
      \item Hussain - A couple pain points I experienced during this
      deliverable had to do with the poor delegation of work and slower
      restart into working on the design document. Our group had decided to
      split the work for the design doc in a same way we did for Rev -1, but
      this gave some of us more work than others as this time around, the MIS
      required more work than the MG. In addition to this, some of us were a
      bit slow (potentially because of the break) in getting back to working
      on the project. Thankfully, I was able to resolve this by re-delegating
      some of the work and helping set up a meeting with the TA to discuss
      the items for the deliverable.
      \item Jeffrey -
      \item Kevin -
    \end{itemize}
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
    \begin{itemize}
      \item Most of our design decisions stemmed from the consulting the primary
      stakeholders of the project, namely ourselves as students and end users of the
      system. Since the software is intended to be used and evaluated by students
      with similar technical backgrounds and needs, our group discussions acted as
      a proxy for client consultation. Particularly, decisions regarding the
      overall modular decomposition were based on stakeholder discussions. As a
      group, we agreed to keep the higher-level module structure provided in the
      template, as it aligned well with the expectations for separation of concerns
      and maintainability. We then refined this structure by collectively defining
      the responsibilities and services of each module, which is reflected in the
      Module Guide.

      \item Many of these stakeholder-driven decisions were mentioned as part of the
      functional and non-functional requirements outlined in the SRS. The design
      of individual modules and their interfaces was guided by these requirements,
      ensuring clear traceability from stakeholder needs to the system-level design.

      \item Some design decisions did not stem directly from stakeholder input but instead
      came from practical constraints and other experiences. For example, user
      interface decisions were informed by common design patterns observed in modern
      drawing and canvas-based applications, helping minimize the learning curve and
      aligning with user expectations. Similarly, the project timeline was
      determined based on course deadlines and workload considerations, rather than
      client input, as these constraints were externally imposed by the course
      structure.
    \end{itemize}
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
    \begin{itemize}
      \item While creating the design document, none of the existing documents required
      major changes. The SRS served as a foundational input to the design process, and the
      module decomposition and interfaces were created specifically to satisfy the
      functional and non-functional requirements defined. As a result, the design document
      did not introduce new requirements or require modifications to the SRS, but instead
      validated that the requirements were implementable and well-scoped.

      \item Similarly, the Hazard Analysis did not require updates as no new hazards were
      identified during the design process. However, the design helped clarify how
      previously identified hazards would be addressed through module separation,
      controlled state mutation, and undo/redo mechanisms, reinforcing the effectiveness
      of existing mitigation strategies.

      \item The design document does, however, influence how the Verification and Validation
      (VnV) Plan would be interpreted and later refined. By clearly defining module
      responsibilities and interfaces, the design gives more precise unit and integration
      testing strategies, which would be reflected in future updates to the VnV plan.

    \end{itemize}
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
  \item (After you have implemented another team's module, which means this
  isn't filled in until after the original deadline). What did you learn by
  implementing another team's module? Were all the details you needed in the
  documentation, or did you need to make assumptions, or ask the other team
  questions?  If your team also had another team implement one of your modules,
  what was this experience like?  Are there things in your documentation you
  could have changed to make the process go more smoothly for when an
  ``outsider'' completes some of the implementation?

  The other team's module was well specified and straightforward to implement.
  We learned how helpful and important clear documentation is for
  collaboration. We were able to implement the module with little knowledge of
  the project as a whole and without needing external context for how this
  module would fit into the larger system. Almost all the details we needed
  were in the documentation. A couple areas where we made assumptions included
  the format of the logging files as well as assuming the referenced "OSDData"
  object structure was JSON. We definitely could have added more detail to our
  documentation to make it easier for the other team to implement. Writing out
  steps in plain english made it clear for us what to implement. We also could
  have specified the exact file path for them to implement. Additionally, the
  module we were assigned was rather small and easy to understand in isolation.
  We could have done a better job of breaking up our modules to allow for this
  type of isolated knowledge requirements during implementation.

\end{enumerate}


\end{document}
